"""Secret Stash Client"""

import base64
from typing import Dict, Union

import boto3
from boto3.dynamodb.types import Binary
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from hyperion import Hyperion


SECRET_TABLE_NAME = 'secret-stash-secrets'


class BucketNameNotFoundError(Exception):
    """Raised when the bucket name cannot be found """


class SecretStash:
    """Methods to fetch data from secretstash"""

    def __init__(self, environment: str, region: str, group: str, secret_name: str, bytes_resp: bool = False):
        """
        Fetches data from secretstash
        :param environment: The habitat name
        :param region: AWS Region
        :param group: Secretstash group / bucket name
        :param secret_name: Secretstash name of secret
        :param bytes_resp: Boolean True returns Bytes, False returns UTF8 String
        """
        # This will cause the client to use the local cache first, and fall back to live hyperion if it can't find the
        #   item in the local cache
        hyperion = Hyperion(cache_first=True)
        regions = hyperion.region()
        region_obj = regions.item(name=region)
        self._bucket_name = region_obj.get('secretStash', {}).get('s3Bucket')
        self.environment = environment
        self.region = region
        self.group = group
        self.secret_name = secret_name
        self.bytes_resp = bytes_resp
        self._path = f'secret_stash/{self.environment}/{self.group}/{self.secret_name}'
        dynamodb = boto3.resource('dynamodb', region_name=self.region)
        self.table = dynamodb.Table(SECRET_TABLE_NAME)
        self.s3 = boto3.resource('s3', region_name=self.region)
        self.kms = boto3.client('kms', region_name=self.region)

    def get(self) -> Union[bytes, str]:
        """
        Gets the secret and decrypts it
        :return: The decrypted and unpadded secret in either bytes or str format, as requested for this instance
        """
        # noinspection PyBroadException
        try:
            return self._get_dynamo()
        except Exception:  # pylint: disable=broad-except
            # We always want to check s3 if the dynamo fetch fails for any reason
            return self._get_s3()

    def _get_dynamo(self) -> Union[bytes, str]:
        """
        Gets the secret from DynamoDB and decrypts it
        :return: The decrypted and unpadded secret in either bytes or str format, as requested for this instance
        """
        res = self.table.get_item(
            Key={
                'path': self._path,
                'environment': self.environment
            }
        )
        return self._decrypt(res['Item'])

    def _get_s3(self) -> Union[bytes, str]:
        """
        Gets the secret from S3 and decrypts it
        :return: The decrypted and unpadded secret in either bytes or str format, as requested for this instance
        """
        obj = self.s3.Object(self.bucket_name, self._path)
        data = {
            'data': obj.get()['Body'].read(),
            'metadata': obj.metadata
        }
        return self._decrypt(data)

    def _unpad(self, padded: bytes) -> Union[bytes, str]:
        """
        Unpads a decrypted secret
        :param padded: The padded secret to unpad
        :return: The unpadded secret in either bytes or str format, as requested for this instance
        """
        padded_char = padded[-1:].decode('utf8')
        result = padded[:-ord(padded_char)]
        if not self.bytes_resp:
            result = result.decode('utf8')
        return result

    def _decrypt(self, data: Dict[str, Union[str, Dict[str, str]]]) -> Union[bytes, str]:
        """
        Decrypts the secret
        :param data: The full data/metadata to use in decrypting the secret
        :return: The decrypted and unpadded secret in either bytes or str format, as requested for this instance
        """
        context = {
            'group': self.group,
            'path': self._path,
            'region': self.region,
            'account': self.environment,
        }
        kms_result = self.kms.decrypt(
            CiphertextBlob=base64.b64decode(data['metadata']['key']),
            EncryptionContext=context
        )
        kms_key = kms_result['Plaintext']
        iv_value = base64.b64decode(data['metadata']['iv'])
        encoded_data = data['data']
        if isinstance(encoded_data, Binary):
            encoded_data = encoded_data.value.decode()
        cypher_text = base64.b64decode(encoded_data)
        cipher = Cipher(algorithms.AES(kms_key), modes.CBC(iv_value))
        decryptor = cipher.decryptor()
        data = decryptor.update(cypher_text) + decryptor.finalize()
        return self._unpad(padded=data)

    @property
    def bucket_name(self) -> str:
        """
        Gets the bucket name from Hyperion
        :return: The discovered bucket name
        """
        if not self._bucket_name:
            raise BucketNameNotFoundError(f'Unknown Region / S3 Bucket name for {self.region}')
        return self._bucket_name
