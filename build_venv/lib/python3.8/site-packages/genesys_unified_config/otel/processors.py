"""helper functions for processors config"""
from typing import Dict

from .constants import PROCESS_BATCH, PROCESS_RESOURCE, PROCESSOR_CUMULATIVE_TO_DELTA, \
    PROCESSOR_RESOURCE_DETECTION_EC2, PROCESSOR_RESOURCE_DETECTION_SYSTEM, PROCESSOR_TAIL_SAMPLING, \
    PROCESSOR_MEMORY_LIMITER, PROCESSOR_PROBABILISTIC_SAMPLER, PROCESS_TRANSFORM_ENTITY, PROCESS_ATTRIBUTES_TRANSFORM, \
    PROCESS_TRANSFORM_TRUNCATE, PROCESSOR_ATTRIBUTES_ERROR_STATUS_CODES

HASH_SEED = 22
SAMPLING_PERCENTAGE = 7


def generate_tag_key(key: str) -> str:
    """maps tag to the otel equivalent semantic name"""
    tag_key_map = {
        'service_name': 'service.name',
        'version': 'service.version',
        'instanceId': 'service.instance.id'
    }
    return f'tags.{tag_key_map.get(key, key)}'


def generate_resource_attributes_config(tags: Dict[str, str],
                                        service_name: str,
                                        instance_id: str,
                                        version: str,
                                        habitat: str):
    """generates resource attributes config"""
    resource_attributes = [
        {'key': 'service.name', 'value': f'{service_name}-{habitat}', 'action': 'upsert'},
        {'key': 'service.instance.id', 'value': instance_id, 'action': 'upsert'},
        {'key': 'service.id', 'value': instance_id, 'action': 'upsert'},
        {'key': 'service.version', 'value': version, 'action': 'upsert'}
    ]

    # Create NewRelic tags from tags.json
    for key, value in tags.items():
        if value:
            resource_attributes.append(
                {'key': generate_tag_key(key), 'value': value, 'action': 'upsert'})

    return resource_attributes


def generate_processors_config(telemetry_config: Dict,
                               service_name: str,
                               habitat: str,
                               instance_id: str,
                               version: str, tags: Dict) -> Dict:
    """generates processor config"""
    config = {
        PROCESSOR_RESOURCE_DETECTION_SYSTEM: {
            'detectors': ['system'],
            'system': {'hostname_sources': ['os', 'dns']}
        },
        PROCESSOR_RESOURCE_DETECTION_EC2: {
            'detectors': ['env', 'ec2'],
            'ec2': {}
        },
        PROCESSOR_CUMULATIVE_TO_DELTA: {},
        PROCESSOR_ATTRIBUTES_ERROR_STATUS_CODES: {
            'include': {
                'match_type': 'regexp',
                'attributes': [{
                    'key': 'http.status_code',
                    'value': '^(4|5)\d{2}$' # pylint: disable=W1401
                }]
            },
            'actions': [{
                'key': 'sampling.priority',
                'value': 100,
                'action': 'upsert'
            }]
        },
        PROCESSOR_PROBABILISTIC_SAMPLER: {
            'hash_seed': HASH_SEED,
            'sampling_percentage': SAMPLING_PERCENTAGE
        },
        PROCESS_TRANSFORM_TRUNCATE: {
            'trace_statements': [{
                'context': 'span',
                'statements': ['truncate_all(attributes, 4095)', 'truncate_all(resource.attributes, 4095)']
            }]
        },
        PROCESS_TRANSFORM_ENTITY: {
            'metric_statements': [{
                'context': 'datapoint',
                'statements': [
                    f'set(attributes["service_name"], "{service_name}-{habitat}") '
                    f'where attributes["service_name"] != nil']
            }]
        },
        PROCESSOR_TAIL_SAMPLING: {
            'policies': [{
                'name': 'NewRelic-Agent',
                'type': 'string_attribute',
                'string_attribute': {'key': 'http.user_agent', 'values': ['NewRelic*'], 'enabled_regex_matching': True,
                                     'invert_match': True}
            }]
        },
        PROCESSOR_MEMORY_LIMITER: {
            'check_interval': '1s',
            'limit_percentage': telemetry_config['memory']['maxPercentage'],
            'spike_limit_percentage': telemetry_config['memory']['spikeLimitPercentage']
        },
        PROCESS_BATCH: {}
    }

    if telemetry_config['traces'].get('attributes'):
        actions_transform = []
        for key, val in telemetry_config['traces']['attributes'].items():
            if val['action'] == 'remove':
                actions_transform.append({
                    'key': key,
                    'action': 'delete'
                })
            elif val['action'] == 'redact':
                actions_transform.append({
                    'key': key,
                    'action': 'update',
                    'value': '****'
                })
        config[PROCESS_ATTRIBUTES_TRANSFORM] = {'actions': actions_transform}

    resource_attributes = generate_resource_attributes_config(tags, service_name, instance_id, version, habitat)
    config[PROCESS_RESOURCE] = {'attributes': resource_attributes}

    return config
