"""Provides both iterator and direct access functionality for interfacing with the cache files"""

import base64
import json
from os import path
from typing import Any, Callable, Dict

from hyperion_cache.exceptions import UnknownHabitatError, UnknownItemTypeError, ItemNotFoundError


CACHE_ROOT = {'path': path.join(path.dirname(path.realpath(__file__)), 'cache-files')}  # Is dict for testing

# Although some would argue we should get rid of Windows and not support it, this code is to support Windows.
# For example, item type sshkey has items named like ephemeral_keys:infra
# The colon is reserved in Windows and cannot be used in a folder or filename.
# List of reserved characters,
# https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file?redirectedfrom=MSDN#file_and_directory_names
# To quote Nicholas Barber "Using a lambda is such a C# thing to do." We are doing it anyways.
ENCODE_STRING: Callable[[str], str] = lambda x: base64.b64encode(x.encode("utf-8"), b"-_").decode()

class FileCache:
    """Methods for accessing information from the hyperion cache files"""

    __slots__ = ('habitat_path',)

    def __init__(self, habitat: str) -> None:
        """
        Sets the habitat path to get cache info from
        :param habitat: The habitat to get the path for
        """
        habitat_path = path.join(CACHE_ROOT['path'], habitat)
        if not path.exists(habitat_path):
            raise UnknownHabitatError(f'The habitat ({habitat}) is not a valid hyperion deployment habitat')
        self.habitat_path = habitat_path

    def _get_item_type_path(self, *, item_type: str) -> str:
        """
        Gets the path to an item type in a habitat
        :param item_type: The item type to get the path for
        :return: The path to the item type's cache directory
        """
        item_type_path = path.join(self.habitat_path, item_type)
        if not path.exists(item_type_path):
            raise UnknownItemTypeError(f'The item type ({item_type}) is not a valid hyperion item type')
        return item_type_path

    def list_items(self, *, item_type: str, **filters) -> Dict[str, Dict[str, Any]]:
        """
        Lists items from the cached item metadata, returning it in a way that is consistent with a Connection
        :param item_type: The type of items to list
        :param filters: The optional filters for the items
        :return: The (filtered) items similar to the HTTP JSON response (what the client's Connection would return)
        """
        with open(
                path.join(self._get_item_type_path(item_type=item_type), 'metadata.json'), 'r', encoding='utf8'
        ) as metadata_file:
            metadata = json.load(metadata_file)
        filtered_content = {}
        for name, item in metadata['content'].items():
            show = True
            # Support for legacy region filter name on habitats
            if 'regionName' in filters:
                if 'region' not in filters:
                    filters['region'] = filters['regionName']
                del filters['regionName']
            for filter_name, filter_value in filters.items():
                if filter_name not in item:
                    show = False
                elif item[filter_name] != filter_value:
                    show = False
            if show:
                filtered_content[name] = item
        return {'content': filtered_content}

    def get_item(self, *, item_type: str, name: str, expanded: bool = False):
        """
        Gets a cached item directly, returning it in a way that is consistent with a Connection
        :param item_type: The type of item to get
        :param name: The name of the item to get
        :param expanded: If the expanded item should be retrieved
        :return: The cached item similar to the HTTP JSON response (what the client's Connection would return)
        """
        item_path = path.join(self._get_item_type_path(item_type=item_type), ENCODE_STRING(name))
        if not path.exists(item_path):
            raise ItemNotFoundError(f'The item ({name}) was not found in the cache for the type ({item_type})')
        if expanded:
            file_path = path.join(item_path, 'expanded.json')
        else:
            file_path = path.join(item_path, 'base.json')
        with open(file_path, 'r', encoding='utf8') as item_file:
            item = json.load(item_file)
        return item
