"""
The uploader to validate and upload the assets
"""
import os
from pathlib import Path
from typing import Any, Dict
from urllib3 import Retry
import requests
from requests.adapters import HTTPAdapter
from requests.exceptions import RequestException
import click
import yaml

from colorama import Fore
from hyperion import Hyperion
from genesys_logging.logger import Logger

from .exceptions import StaticAssetNotFoundException, SignedUrlNotFound, S3UploadException, \
    EnvironmentValidationException, S3AssetValidationException, CloudformationAssetValidationException
from .infra_api_client import InfraApiClient
from .static_asset_config import StaticAssetConfig

logger = Logger(clear_formatters=True)

# 1 gig
LARGE_FILE_SIZE_THRESHOLD = 1024 * 1024 * 1024

http_adapter = HTTPAdapter(max_retries=Retry(
    total=5,
    backoff_factor=1,
    status_forcelist=[429, 500, 502, 503, 504],
    method_whitelist=['POST', 'PUT'],
    raise_on_status=True
))
session = requests.Session()


# pylint: disable=R0902
class StaticAssetUploader:
    """
    This will validate that the assets provided in the path actually
    exist and then do the upload action
    """
    def __init__(self, root_path, service_version, service_envs, api_env, secret_group_env, app_metadata,
                 cluster_name=None):
        self.root_path = root_path
        self.static_assets = StaticAssetConfig(self.root_path, cluster_name)
        self.static_asset_config = self.static_assets.get_config()
        self.service_version = service_version
        self.service_name = self.static_assets.service_name
        self.service_envs = service_envs
        self.app_metadata = app_metadata
        self.api_env = api_env
        self.secret_group_env = secret_group_env
        self.static_asset_artifacts = {}
        self.infra_api_client = InfraApiClient(api_env=self.api_env, secret_group_env=self.secret_group_env)
        self.hyperion = Hyperion()
        self.habitat = self.hyperion.habitat()

    def validate_assets_exist(self, paths):
        """
        validates that each of the src paths provided in the static
        asset config are actually existing
        :param paths: the paths to the artifacts
        :return: None
        """
        click.echo(f'{click.style(f" Verifying that the paths -  {paths} exist:", fg="green")}', color=True)
        if paths:
            for key, path in paths.items():
                assets_exist = os.path.exists(path)
                if not assets_exist:
                    click.echo(f'{click.style(f" The path -  {path} does not exist:", fg="red")}', color=True)
                    #pylint: disable=C0301,E1101
                    raise StaticAssetNotFoundException(f'{Fore.RED} ERROR: Could not find asset for {key} '
                                                       f'in the resolved path - {path}. The paths specified '
                                                       f'in the config must be relative to the workspace. ')

    def upload_assets(self):
        """
        Function that will validate and upload the static assets to s3
        :return: None
        """
        assets = self.static_assets.get_config().get('assets')
        # pylint: disable=W0612
        for key, asset_config in assets.items():
            self.static_asset_artifacts[key] = f'{self.root_path}/{self.static_assets.get_src(key)}'
        self.validate_assets_exist(self.static_asset_artifacts)
        register_response = self.register_assets(self.service_name, self.service_version)
        self.upload_to_s3(register_response)
        self.validate_assets_in_s3(self.service_name, self.service_version)
        self.validate_resources_in_static_asset_config(self.service_name, self.service_version, self.service_envs)

    def register_assets(self, service_name, service_version) -> Dict[str, Any]:
        """ Makes an api call to the promote service register endpoint to register assets"""
        register_path = f'/v1/promote/assets/serviceName/{service_name}/serviceVersion/{service_version}'
        register_json = {
            "appMetadata": self.app_metadata,
            "staticAssets": self.static_asset_config
        }
        # pylint: disable=C0301
        message = f" Calling infra-api ({self.api_env}) to register the assets for {service_name}, {service_version}"
        click.echo(f'{click.style(message, fg="green")}', color=True)
        click.echo(f'{click.style(f" POST {register_path}", fg="cyan")}', color=True)
        click.echo(f'{click.style(f" {yaml.dump(register_json)}", fg="cyan")}', color=True)
        response = self.infra_api_client.post(path=register_path, json=register_json)
        return response.json()['content']

    def upload_to_s3(self, register_response):  # pylint: disable=R0201
        """
        uploads the artifacts to s3 using the signed urls generated by the promote service
        :param register_response: The response from the promote/register api call
        :return: None
        """
        click.echo(f'{click.style(" Uploading artifacts to s3", fg="green")}', color=True)
        if not register_response:
            # pylint: disable=E1101
            raise SignedUrlNotFound(f" {Fore.RED}ERROR: Pre signed data required to make the s3 upload was none")

        for asset_name, asset_path in self.static_asset_artifacts.items():
            click.echo(f'{click.style(f" Uploading {asset_path} to s3", fg="green")}', color=True)
            try:
                asset_file = Path(asset_path)
                asset_size = asset_file.stat().st_size
                if asset_size >= LARGE_FILE_SIZE_THRESHOLD:
                    self.upload_large_file_to_s3(asset_name, asset_size, asset_file)
                else:
                    self.upload_file_to_s3(asset_name, asset_path, register_response.get(asset_name))
            except RequestException as s3_post_exception:
                # pylint: disable=E1101
                raise S3UploadException(f" {Fore.RED}ERROR : There was an exception making a post request for s3 upload"
                                        f"- {s3_post_exception}")

            click.echo(f'{click.style("Completed s3 upload ", fg="green")}', color=True)

    def upload_file_to_s3(self, asset_name, asset_path, asset_upload_info):  # pylint: disable=R0201
        """
        uploads the artifacts to s3 using the signed urls generated by the promote service
        :param asset_name: The asset name
        :param asset_path: The asset path
        :param asset_upload_info: The asset pre-signed post url and fields
        :return: None
        """
        with open(asset_path, 'rb') as file:
            url = asset_upload_info['url']
            fields = asset_upload_info['fields']
            files = {'file': (asset_path, file)}

            session.mount(url, http_adapter)
            session.post(url, data=fields, files=files)
            click.echo(f'{click.style(f" Upload complete for asset {asset_name} - {file} ", fg="green")}', color=True)

    def upload_multipart_create(self, asset_name, asset_size) -> Dict[str, Any]:
        """
        Makes an api call to the promote service to start a large multipart file upload
        and get the pre-signed urls
        """
        # pylint: disable=C0301
        upload_create_path = f'/v1/promote/assets/serviceName/{self.service_name}/serviceVersion/{self.service_version}/upload/create'
        upload_create_json = {
            "assetName": asset_name,
            "assetSize": asset_size
        }
        # pylint: disable=C0301
        message = f" Calling infra-api ({self.api_env}) to create multipart upload for asset {asset_name} " \
                  f"({asset_size}) for {self.service_name} version {self.service_version}"
        click.echo(f'{click.style(message, fg="green")}', color=True)
        click.echo(f'{click.style(f" POST {upload_create_path}", fg="cyan")}', color=True)
        click.echo(f'{click.style(f" {yaml.dump(upload_create_json)}", fg="cyan")}', color=True)
        response = self.infra_api_client.post(path=upload_create_path, json=upload_create_json)
        return response.json()['content']

    def upload_multipart_complete(self, asset_name, upload_id, uploaded_parts) -> Dict[str, Any]:
        """ Makes an api call to the promote service to complete a large multipart file upload"""
        # pylint: disable=C0301
        upload_complete_path = f'/v1/promote/assets/serviceName/{self.service_name}/serviceVersion/{self.service_version}/upload/complete'
        upload_complete_json = {
            "assetName": asset_name,
            "uploadId": upload_id,
            "uploadedParts": uploaded_parts
        }
        # pylint: disable=C0301
        message = f" Calling infra-api ({self.api_env}) to complete multipart upload for asset {asset_name} for " \
                  f"{self.service_name} version {self.service_version}"
        click.echo(f'{click.style(message, fg="green")}', color=True)
        click.echo(f'{click.style(f" POST {upload_complete_path}", fg="cyan")}', color=True)
        # click.echo(f'{click.style(f" {yaml.dump(upload_complete_json)}", fg="cyan")}', color=True)
        click.echo(f'{click.style(f" {asset_name}", fg="cyan")}', color=True)
        click.echo(f'{click.style(f" {upload_id}", fg="cyan")}', color=True)
        click.echo(f'{click.style(f" {len(uploaded_parts)}", fg="cyan")}', color=True)
        self.infra_api_client.post(path=upload_complete_path, json=upload_complete_json)

    def upload_large_file_to_s3(self, asset_name, asset_size, asset_file):
        """
        uploads the artifacts to s3 using the signed urls generated by the promote service
        :param asset_name: The name of the asset
        :param asset_size: The size of the asset file
        :param asset_file: The asset file
        :return: None
        """
        upload_info = self.upload_multipart_create(asset_name, asset_size)
        upload_id = upload_info.get('uploadId')
        upload_parts = upload_info.get('uploadParts')
        upload_num_parts = len(upload_parts)

        uploaded_parts = []
        with asset_file.open('rb') as fin:
            for upload_part in upload_parts:
                part_url = upload_part['uploadUrl']
                part_number = upload_part['partNumber']
                # pylint: disable=C0301
                message = f" uploading part {part_number} of {upload_num_parts} for {asset_name}: {part_url}"
                click.echo(f'{click.style(message, fg="green")}', color=True)
                chunk = fin.read(upload_part['partSize'])
                session.mount(part_url, http_adapter)
                res = session.put(part_url, data=chunk)
                etag = res.headers['ETag']
                uploaded_parts.append({'ETag': etag, 'PartNumber': part_number})

        self.upload_multipart_complete(asset_name, upload_id, uploaded_parts)

    def validate_assets_in_s3(self, service_name, service_version):
        """ Makes an api call to promote service validate assets endpoint to validate if assets have been uploaded to
        the correct s3 bucket """
        # pylint: disable=C0301
        message = f" Calling infra-api ({self.api_env}) to validate assets for {service_name}, {service_version}"
        click.echo(f'{click.style(message, fg="green")}', color=True)
        response = self.infra_api_client.post(
            path=f'/v1/promote/assets/serviceName/{service_name}/serviceVersion/{service_version}/validateAssets')

        if 'error' in response:
            click.echo(
                f'{click.style(f"Could not validate assets for {service_name}, {service_version}", fg="red")}',
                color=True)
            # pylint: disable=C0301,E1101
            raise S3AssetValidationException(f"{Fore.RED}ERROR: There was an exception validating assets exist in S3 "
                                             f"for {service_name}, {service_version}. The error message is {response}")

        click.echo(f'{click.style(f"Assets exist in s3 for {service_name} {service_version}", fg="green")}', color=True)

    def validate_resources_in_static_asset_config(self, service_name, service_version, service_envs):
        """ Makes an api call to promote service validate resources endpoint to validate if assets are present in the
        cloudformation stack """

        static_asset_envs = set(item["name"] for item in self.habitat.iterate(static_asset_validation=True,
                                                                              name_only=True))

        for each_service_env in service_envs:
            # pylint: disable=C0301
            message = f"Calling Hyperion to check if promoteAssumableRole has been set for {each_service_env}"
            click.echo(f'{click.style(message, fg="magenta")}', color=True)

            if each_service_env not in static_asset_envs:
                logger.info(message="There is no promoteAssumableRole for {each_service_env}. Raising user error.")
                # pylint: disable=E1101
                raise EnvironmentValidationException(
                    f"{Fore.RED}ERROR: {each_service_env} is not a valid environment. Please check your environment list.")
            # pylint: disable=C0301
            message = f"Calling infra-api ({self.api_env}) to validate resources for {service_name}, " \
                      f"{service_version}, {each_service_env}"
            click.echo(f'{click.style(message, fg="green")}', color=True)
            response = self.infra_api_client.post(
                path=f'/v1/promote/assets/serviceName/{service_name}/serviceVersion/{service_version}/env/{each_service_env}/validateResources')

            if 'error' in response:
                click.echo(f'{click.style(f"Error check: {response}", fg="red")}', color=True)
                failure_code = response.get('error')
                failure_reason = response.get('errorDescription', '')
                if failure_code == 'UnprocessableEntity':
                    # pylint: disable=E1101
                    raise CloudformationAssetValidationException(
                        f"{Fore.RED}ERROR: There was an exception validating assets exist in Cloudformation for "
                        f"{service_name}, {service_version}. The error message is {failure_reason}")
                # pylint: disable=E1101
                click.echo(f"{Fore.YELLOW}WARNING: Asset Validation in Cloudformation failed for {service_name}, "
                           f"{service_version}, {each_service_env} due to {failure_code}, {failure_reason}")
            else:
                message = f"Assets exist in Cloudformation for {service_name}, {service_version}, {each_service_env}"
                click.echo(f'{click.style(message, fg="green")}', color=True)
