"""Base item"""

from abc import ABCMeta, abstractmethod
from typing import Any, Dict, Generator, List, Union

from pybreaker import CircuitBreakerError
from requests import ConnectionError, Timeout  # pylint: disable=redefined-builtin

from hyperion_cache import FileCache, ItemNotFoundError

from hyperion.connections import ConnectionManager
from hyperion.exceptions import ExpandedWriteError, FileCacheWriteError, CustomHTTPError, ExpandedNameError


class Item(dict):
    """Custom dict of the item with its supporting functionality"""

    def __init__(self, connection: ConnectionManager, item_type: str, name: str, lock_timestamp: int = None) -> None:
        """
        Custom container for items
        :param connection: The connection manager to use when making API calls
        :param item_type: The type of item represented bt this object
        :param name: The name of this item
        :param lock_timestamp: The lock timestamp to include when loading the item
        """
        self.connection = connection
        self.item_type = item_type
        self.name = name
        self.lock_timestamp = lock_timestamp

        # Internal variable used to manage the write conflict resolution key
        self._write_check_guid = None

        # Populated with the filter fields when the item is fetched as part of an iterator
        self.filter_fields = {}

        # Can be checked to determine if the item is in its expanded representation or not
        self.expanded = False

        # Can be checked to see if the item exists in hyperion or not.
        #   Only available immediately after an initial interface instantiation that results in a 404.
        self.exists = False

        # This variable will get set to True if it is loaded from the file cache.
        self.file_cache = False

        super().__init__()

    @property
    def params(self) -> Dict[str, Union[str, List[str]]]:
        """
        Gets query params for a request. Sets the ts param to the lock_timestamp if set on this instance.
        :return: The query params for a request
        """
        params = {}
        if self.lock_timestamp:
            params['ts'] = str(self.lock_timestamp)
        return params

    def load(self) -> None:
        """Loads the item from the API"""
        result = self.connection.get(
            url_path=f'item_type/{self.item_type}/name/{self.name}',
            params=self.params
        )
        self.clear()
        self.update(result['content']['properties'])
        self._write_check_guid = result['content']['write_check_guid']
        self.expanded = False
        self.exists = True

    def expand(self) -> None:
        """Loads the expanded item from the API"""
        result = self.connection.get(
            url_path=f'item_type/{self.item_type}/name/{self.name}/expanded',
            params=self.params
        )
        self.clear()
        self.update(result['content']['properties'])
        self._write_check_guid = None
        self.expanded = True
        self.exists = True

    def save(self) -> None:
        """Saves the current state of the item"""
        if self.expanded:
            raise ExpandedWriteError('An expanded item cannot be saved, re-load the item before attempting to save it')
        if self.file_cache:
            raise FileCacheWriteError('An item retrieved from the file cache cannot be saved')
        if self._write_check_guid:
            result = self.connection.put(
                url_path=f'item_type/{self.item_type}/name/{self.name}',
                json_body={'properties': self, 'write_check_guid': self._write_check_guid}
            )
        else:
            result = self.connection.post(
                url_path=f'item_type/{self.item_type}',
                json_body={'properties': self}
            )
        self.clear()
        self.update(result['content']['properties'])
        self._write_check_guid = result['content']['write_check_guid']
        self.expanded = False
        self.exists = True


class Interface(metaclass=ABCMeta):
    """Assists in getting, finding, and iterating over items"""

    __slots__ = ('connection', 'lock_timestamp', 'cache_file_fallback', 'cache_first', 'file_cache')

    def __init__(
            self,
            connection: ConnectionManager,
            lock_timestamp: int = None,
            cache_file_fallback: bool = True,
            cache_first: bool = False
    ) -> None:
        """
        Stores connection info and locking timestamp for this finder
        :param connection: The connection manager to use when making calls
        :param lock_timestamp: The lock timestamp to include on GET calls
        :param cache_file_fallback: If True, falls back to cache files on a CustomHTTPError or CircuitBreakerError
            encountered during a GET request
        :param cache_first: If True, hits the cache first, falling back to the hyperion service if an item is not found
        """
        self.connection = connection
        self.lock_timestamp = lock_timestamp
        self.cache_file_fallback = cache_file_fallback
        self.cache_first = cache_first
        if self.cache_file_fallback:
            self.file_cache = FileCache(habitat=connection.habitat)

    @property
    @abstractmethod
    def item_type(self) -> str:  # pragma: no cover
        """The item type represented by this interface"""
        # This is an example, subclasses should return their respective item types
        return 'item'

    @staticmethod
    def _convert_filters(**filters) -> Dict[str, Any]:
        """
        Converts filters from their python snake case format into the camel case format that hyperion expects
        :param filters: The filters as their python kwargs
        :return: The converted filters ready for hyperion
        """
        clean_filters = {}
        for key, value in filters.items():
            if value is not None:
                split_key = key.split('_')
                filter_key = split_key[0]
                for part in split_key[1:]:
                    filter_key += part.capitalize()
                clean_filters[filter_key] = value
        return clean_filters

    def _query_params(self, **filters) -> Dict[str, Union[str, List[str]]]:
        """
        Gets query params for a request. Sets the ts param to the lock_timestamp if set on this instance.
            Also adds any additional filters to the params after formatting them correctly.
        :param filters: The optional filter params to format
        :return: The query params for a request
        """
        params = {f'filter.{key}': value for key, value in self._convert_filters(**filters).items()}
        if self.lock_timestamp:
            params['ts'] = str(self.lock_timestamp)
        return params

    def _list_all(self, expanded: bool = False, name_only: bool = False, **filters) -> Generator[Item, None, None]:
        """
        Makes a list call and iterates over the results, yielding the loaded/expanded Item
        :param expanded: If True, iterates over expanded items
        :param name_only: If True, returns items with only their names and does not load them
        :param filters: The filters to use in generating query params for the request
        :return: A generator that will iterate over and load/expand items
        """
        if expanded and name_only:
            raise ExpandedNameError('expanded and name_only are mutually exclusive arguments')
        iterate_fallback = False
        if self.cache_first:
            result = self.file_cache.list_items(item_type=self.item_type, **self._convert_filters(**filters))
        else:
            try:
                result = self.connection.get(
                    url_path=f'item_type/{self.item_type}',
                    params=self._query_params(**filters)
                )
            except (CustomHTTPError, CircuitBreakerError, ConnectionError, Timeout):
                if not self.cache_file_fallback:
                    raise
                iterate_fallback = True
                result = self.file_cache.list_items(item_type=self.item_type, **self._convert_filters(**filters))
        for name, filter_fields in result['content'].items():
            if name_only:
                item = Item(
                    connection=self.connection, item_type=self.item_type, name=name, lock_timestamp=self.lock_timestamp
                )
                item['name'] = name
                item.exists = True
            else:
                item = self.item(name=name, expanded=expanded, iterate_fallback=iterate_fallback)
            item.filter_fields = filter_fields
            yield item

    @abstractmethod
    def iterate(self, expanded: bool = False, name_only: bool = False, **filters) -> Generator[Item, None, None]:
        """
        Gets many items of the current type
        :param expanded: If True, iterates over expanded items
        :param name_only: If True, returns items with only their names and does not load them
        :param filters: The filters for this item (differs on each type)
        :return: A generator that will iterate over and load items
        """
        # This is an example, subclasses should define filters explicitly
        yield from self._list_all(expanded=expanded, name_only=name_only, **filters)   # pragma: no cover

    def _http_item(self, name: str, expanded: bool = False) -> Item:
        """
        Gets an individual item from the hyperion service
        :param name: The name of the item to get
        :param expanded: If True, gets the expanded version of the item
        :return: The loaded/expanded instance for the retrieved item
        """
        item = Item(connection=self.connection, item_type=self.item_type, name=name, lock_timestamp=self.lock_timestamp)
        try:
            if expanded:
                item.expand()
            else:
                item.load()
        except CustomHTTPError as ex:
            if not self.cache_file_fallback and ex.response.status_code == 404:
                # This allows easy writing of new records on cache-less clients
                pass
            elif ex.response.status_code != 410:
                raise
        return item

    def _cache_item(self, name: str, expanded: bool = False) -> Item:
        """
        Gets an individual item from the file cache
        :param name: The name of the item to get
        :param expanded: If True, gets the expanded version of the item
        :return: The loaded/expanded instance for the retrieved item
        """
        item = Item(connection=self.connection, item_type=self.item_type, name=name, lock_timestamp=self.lock_timestamp)
        cached_item = self.file_cache.get_item(item_type=self.item_type, name=name, expanded=expanded)
        item.update(cached_item['content']['properties'])
        item.exists = True
        item.file_cache = True
        if expanded:
            item.expanded = True
        return item

    def item(self, name: str, expanded: bool = False, iterate_fallback: bool = False) -> Item:
        """
        Gets an individual item and loads it, returning a blank item if it does not exist
        :param name: The name of the item to get
        :param expanded: If True, gets the expanded version of the item
        :param iterate_fallback: Set internally to denote a failed iterate call that fell back to the file cache.
            Under this condition, the item lookup itself should also utilize the file cache to ensure data consistency.
        :return: The loaded/expanded instance for the retrieved item
        """
        if self.cache_first or iterate_fallback:
            try:
                return self._cache_item(name=name, expanded=expanded)
            except ItemNotFoundError:
                return self._http_item(name=name, expanded=expanded)
        else:
            try:
                return self._http_item(name=name, expanded=expanded)
            except (CustomHTTPError, CircuitBreakerError, ConnectionError, Timeout):
                if not self.cache_file_fallback:
                    raise
                return self._cache_item(name=name, expanded=expanded)
