"""Managers for the server configuration and connection"""

from abc import ABCMeta, abstractmethod
from base64 import b64encode
from configparser import ConfigParser
from functools import partial, wraps
import json
from operator import attrgetter
from os import environ, path
from sys import getsizeof
import time
from typing import Any, Callable, Dict, List, Union

from cachetools import cachedmethod, TTLCache
from cachetools.keys import hashkey
from pybreaker import CircuitBreaker
import requests
from requests import Session, Response, HTTPError, ConnectionError, ReadTimeout  # pylint: disable=redefined-builtin
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

from hyperion.exceptions import (
    UnsupportedMethodError, InfraApiLoginError, RegionNotFoundError, CustomHTTPError, RequestClientError,
    RequestServerError
)


REGION_SHORT_NAME_MAP = {
    'north': 'n',
    'south': 's',
    'east': 'e',
    'west': 'w',
    'northeast': 'ne',
    'northwest': 'nw',
    'southeast': 'se',
    'southwest': 'sw',
    'central': 'c'
}

DEV_INFRA_API_HYPERION_ROOT = 'https://infra-api.us-east-1.inindca.com/v1/hyperion'
DEV_INFRA_AUTH_CLIENT_URL = 'https://infra-auth.us-east-1.inindca.com/v2/oauth/token'

INFRA_API_HYPERION_ROOT = 'https://infra-api.us-east-1.ininica.com/v1/hyperion'
INFRA_AUTH_CLIENT_URL = 'https://infra-auth.us-east-1.ininica.com/v2/oauth/token'

GET = 'GET'
POST = 'POST'
PUT = 'PUT'

DEFAULT_REQUEST_TIMEOUT = 3
DEFAULT_WRITE_TIMEOUT = 6.1
DEFAULT_RETRY_COUNT = 3
DEFAULT_RETRY_BACKOFF_FACTOR = 1
DEFAULT_RETRY_STATUS_CODES = [429, 500, 502, 503, 504]
DEFAULT_RETRY_METHODS = [GET, POST, PUT]

MAX_CACHE_SIZE = 1024 * 1024 * 8  # 8 MiB
DEFAULT_CACHE_TTL = 900  # 15 minutes

DEFAULT_CIRCUIT_BREAKER_FAILS = 5
DEFAULT_CIRCUIT_BREAKER_TIMEOUT = 30

INSTANCE_METADATA_TOKEN_TIMEOUT = '21600'  # 6 hours (max time for these tokens)

DISCOVER_FUNCTION = 'deploy-HyperionDiscover'  # The name of the lambda function to invoke to get the Hyperion root URL


def circuit_breaker(breaker: Callable[[object], CircuitBreaker]) -> Callable[..., Any]:
    """
    Decorator that calls an instance level circuit breaker with the function that requires it
    :param breaker: An attrgetter pointing to the instance level circuit breaker
    :return: The result of the function wrapped in its instance's circuit breaker
    """
    def decorator(func):
        @wraps(func)
        def wrapper(self, *args, **kwargs):
            return breaker(self)(func)(self, *args, **kwargs)
        return wrapper
    return decorator


def _sorted_obj(obj: Union[List[Any], Dict[Any, Any]]) -> tuple:
    """
    Recursively searches a JSON body, returning sorted tuples for use in hash keys
    :param obj: The current object we are sorting
    :return: A tuple of the sorted obj
    """
    result_list = []
    if isinstance(obj, list):
        iterable = obj
    else:  # Must be a dict
        iterable = sorted(obj)  # If dict keys are not in order we will end up with an incorrect hash
    for key in iterable:
        if isinstance(obj, list):
            value = key
        else:  # Must be a dict
            result_list.append(key)
            value = obj[key]
        if isinstance(value, (dict, list)):
            result_list.append(_sorted_obj(obj=value))
        else:
            result_list.append(value)
    return tuple(result_list)


def keygen(
        *args,
        headers: Dict[str, str] = None,
        params: Dict[str, Union[str, List[str]]] = None,
        json_body: Dict[str, Any] = None,
        **kwargs
) -> tuple:
    """
    Generates a cache key for the un-hashable keyword args
    :param args: The hashable args
    :param headers: The headers to hash
    :param params: The params to hash
    :param json_body: The JSON body to hash
    :param kwargs: The hashable kwargs
    :return: A hash key
    """
    key = hashkey(*args, **kwargs)
    if headers:
        key += tuple(sorted(headers.items()))
    else:
        key += ('headers', None)
    if params:
        key += tuple(sorted(params.items()))
    else:
        key += ('params', None)
    if json_body:
        key += _sorted_obj(obj=json_body)
    else:
        key += ('json_body', None)
    return key


class TimeoutHTTPAdapter(HTTPAdapter):
    """Extends HTTPAdapter with universal timeout support"""

    def __init__(self, *args, **kwargs) -> None:
        """
        Sets a default timeout
        :param args: The args for HTTPAdapter
        :param kwargs: The kwargs for HTTPAdapter with the addition of 'timeout'
        """
        self.timeout = kwargs.pop('timeout')
        self.write_timeout = kwargs.pop('write_timeout')
        super().__init__(*args, **kwargs)

    def send(self, request, **kwargs) -> Response:  # pylint: disable=arguments-differ
        """
        Applies the default timeout to the request if one was not specified for this specific request before sending it
        :param request: The request to send
        :param kwargs: The kwargs for the request
        :return: A requests Response object
        """
        if not kwargs.get('timeout'):
            if request.method in ['PUT', 'POST', 'PATCH', 'DELETE']:
                kwargs['timeout'] = self.write_timeout
            else:
                kwargs['timeout'] = self.timeout
        return super().send(request, **kwargs)


class ConnectionManager(metaclass=ABCMeta):
    """Base class for connection managers"""

    __slots__ = ('session', 'request_map', 'cache', 'breaker', 'habitat')

    def __init__(
            self,
            dev: bool = False,
            timeout_seconds: Union[int, float] = DEFAULT_REQUEST_TIMEOUT,
            write_timeout_seconds: Union[int, float] = DEFAULT_WRITE_TIMEOUT,
            retry_count: int = DEFAULT_RETRY_COUNT,
            retry_backoff_factor: int = DEFAULT_RETRY_BACKOFF_FACTOR,
            retry_status_codes: List[int] = None,
            retry_methods: List[str] = None,
            cache_ttl: int = DEFAULT_CACHE_TTL,
            circuit_breaker_fail_max: int = DEFAULT_CIRCUIT_BREAKER_FAILS,
            circuit_breaker_timeout: int = DEFAULT_CIRCUIT_BREAKER_TIMEOUT
    ) -> None:
        """
        Sets up retrying on requests made with the session
        :param dev: Used to determine if the client should talk to hyperion in dev or infra
        :param timeout_seconds: The number of seconds to wait before considering a read request timed out
        :param write_timeout_seconds: The number of seconds to wait before considering a write request timed out
        :param retry_count: The maximum number of retries
        :param retry_backoff_factor: The exponential backoff factor on retries
            Calculated according to: {backoff factor} * (2 ** ({number of total retries} - 1))
            For example, setting this to 1 Results in an exponential backoff in seconds of 0.5, 1, 2, 4, 8, 16, 32, ...
        :param retry_status_codes: The HTTP status codes on which to retry
        :param retry_methods: The HTTP methods on which to retry,
        :param cache_ttl: The request cache TTL in seconds
            Set to 0 to effectively disable the cache
        :param circuit_breaker_fail_max: The number of failures within the timeout that will trip the breaker
        :param circuit_breaker_timeout: The number of seconds before the circuit breaker resets
            Set to 0 to effectively disable the circuit breaker
        """

        # Set the habitat to talk to hyperion in
        if dev:
            self.habitat = 'dev'
        else:
            self.habitat = 'infra'

        # Set up the requests session and mount the adapters
        self.session = Session()
        if retry_status_codes is None:
            retry_status_codes = DEFAULT_RETRY_STATUS_CODES
        if retry_methods is None:
            retry_methods = DEFAULT_RETRY_METHODS
        adapter = TimeoutHTTPAdapter(
            timeout=timeout_seconds,
            write_timeout=write_timeout_seconds,
            max_retries=Retry(
                total=retry_count,
                backoff_factor=retry_backoff_factor,
                status_forcelist=retry_status_codes,
                method_whitelist=retry_methods,
                raise_on_redirect=False,
                raise_on_status=False
            )
        )
        self.session.mount(prefix='http://', adapter=adapter)
        self.session.mount(prefix='https://', adapter=adapter)

        # A map of supported HTTP methods to the functions on the session they will call
        self.request_map = {
            GET: self.session.get,
            POST: self.session.post,
            PUT: self.session.put
        }

        # Set up the cache to use on requests
        self.cache = TTLCache(maxsize=MAX_CACHE_SIZE, ttl=cache_ttl, timer=time.time, getsizeof=getsizeof)

        # Set up the circuit breaker to use on requests
        self.breaker = CircuitBreaker(
            fail_max=circuit_breaker_fail_max,
            reset_timeout=circuit_breaker_timeout,
            name='RequestBreaker',
            exclude=[RequestClientError]
        )

        # Run the initial connection
        self.connect()

    @abstractmethod
    def connect(self):
        """Initializes or re-connects in an active connection, adding default headers after connecting"""
        with open(path.join(path.dirname(path.realpath(__file__)), 'version_info.json'), 'r') as version_info:
            version = json.loads(version_info.read())['version']
        self.session.headers.update(
            {
                'Content-Type': 'application/json',
                'X-Hyperion-Client-Version': f'python:{version}'
            }
        )

    @circuit_breaker(breaker=attrgetter('breaker'))
    def _request(
            self,
            method: str,
            url: str,
            headers: Dict[str, str] = None,
            params: Dict[str, Union[str, List[str]]] = None,
            json_body: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """
        Makes an HTTP request with the session and returns its response:
            Separated from the "_make_request" function for circuit breaker isolation from the cache
        :param method: The string representation of the HTTP method to use in this request
        :param url: The URL the request is being made to
        :param headers: The optional headers for the request. This is merged (overriding) with the session headers.
        :param json_body: The optional JSON body for the request
        :return: The deserialized JSON result from the request
        """
        response = self.request_map[method](url=url, headers=headers, json=json_body, params=params)
        try:
            response.raise_for_status()
        except HTTPError as ex:
            if ex.response.status_code < 500 and ex.response.status_code != 429:
                raise RequestClientError(response=response) from ex
            raise RequestServerError(response=response) from ex
        return response.json()

    @cachedmethod(cache=attrgetter('cache'), key=partial(keygen, 'request'))
    def _make_request(
            self,
            method: str,
            url: str,
            headers: Dict[str, str] = None,
            params: Dict[str, Union[str, List[str]]] = None,
            json_body: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """
        Centralized manager to handle requests and their exceptions, while universally decoding the JSON responses
        :param method: The string representation of the HTTP method to use in this request
        :param url: The URL the request is being made to
        :param headers: The optional headers for the request. This is merged (overriding) with the session headers.
        :param json_body: The optional JSON body for the request
        :return: The deserialized JSON result from the request
        """
        try:
            response = self._request(method=method, url=url, headers=headers, params=params, json_body=json_body)
        except CustomHTTPError as ex:
            if ex.response.status_code == 401:
                # Our session may have expired, attempt a new connection and re-try the request
                self.connect()
                response = self._request(method=method, url=url, headers=headers, params=params, json_body=json_body)
            elif ex.response.status_code == 409:
                # We hit a conflict so it is best to evict the cache
                self.cache.clear()
                raise
            else:
                raise
        return response

    # pylint: disable=no-self-use
    def get(
            self,
            url_path: str,
            headers: Dict[str, str] = None,
            params: Dict[str, Union[str, List[str]]] = None
    ) -> Dict[str, Any]:
        """
        Performs a GET request
            Exists here to provide a common interface while disallowing it on connections that do not implement it.
        :param url_path: The path under the root URL to hit
        :param headers: The optional headers for the requests. This is merged (overriding) with the session headers
        :param params: The optional query parameters for the request
        :return: The deserialized JSON result from the request
        """
        raise UnsupportedMethodError('This connection manager does not support the GET method')

    # pylint: disable=no-self-use
    def post(
            self,
            url_path: str,
            headers: Dict[str, str] = None,
            params: Dict[str, Union[str, List[str]]] = None,
            json_body: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """
        Performs a POST request
            Exists here to provide a common interface while disallowing it on connections that do not implement it.
        :param url_path: The path under the root URL to hit
        :param headers: The optional headers for the requests. This is merged (overriding) with the session headers
        :param params: The optional query parameters for the request
        :param json_body: The optional JSON body for the request
        :return: The deserialized JSON result from the request
        """
        raise UnsupportedMethodError('This connection manager does not support the POST method')

    # pylint: disable=no-self-use
    def put(
            self,
            url_path: str,
            headers: Dict[str, str] = None,
            params: Dict[str, Union[str, List[str]]] = None,
            json_body: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """
        Performs a PUT request
            Exists here to provide a common interface while disallowing it on connections that do not implement it.
        :param url_path: The path under the root URL to hit
        :param headers: The optional headers for the requests. This is merged (overriding) with the session headers
        :param params: The optional query parameters for the request
        :param json_body: The optional JSON body for the request
        :return: The deserialized JSON result from the request
        """
        raise UnsupportedMethodError('This connection manager does not support the PUT method')


class InfraApiConnection(ConnectionManager):
    """Connection manager for infra-api"""

    __slots__ = (
        'session', 'request_map', 'cache', 'breaker', 'habitat', 'client_id', 'client_secret', 'auth_url', 'root_url'
    )

    def __init__(
            self,
            client_id: str,
            client_secret: str,
            dev: bool = False,
            timeout_seconds: Union[int, float] = DEFAULT_REQUEST_TIMEOUT,
            write_timeout_seconds: Union[int, float] = DEFAULT_WRITE_TIMEOUT,
            retry_count: int = DEFAULT_RETRY_COUNT,
            retry_backoff_factor: int = DEFAULT_RETRY_BACKOFF_FACTOR,
            retry_status_codes: List[int] = None,
            retry_methods: List[str] = None,
            cache_ttl: int = DEFAULT_CACHE_TTL,
            circuit_breaker_fail_max: int = DEFAULT_CIRCUIT_BREAKER_FAILS,
            circuit_breaker_timeout: int = DEFAULT_CIRCUIT_BREAKER_TIMEOUT
    ) -> None:
        """
        Sets up the client ID and secret
        :param client_id: The client ID for this connection
        :param client_secret: The client secret for this connection
        :param dev: Used to determine if the client should talk to hyperion in dev or infra
        :param timeout_seconds: The number of seconds to wait before considering a request timed out
        :param write_timeout_seconds: The number of seconds to wait before considering a write request timed out
        :param retry_count: The maximum number of retries
        :param retry_backoff_factor: The exponential backoff factor on retries
            Calculated according to: {backoff factor} * (2 ** ({number of total retries} - 1))
            For example, setting this to 1 Results in an exponential backoff in seconds of 0.5, 1, 2, 4, 8, 16, 32, ...
        :param retry_status_codes: The HTTP status codes on which to retry
        :param retry_methods: The HTTP methods on which to retry
        :param cache_ttl: The request cache TTL in seconds, set to 0 to effectively disable the cache
        :param circuit_breaker_fail_max: The number of failures within the timeout that will trip the breaker
        :param circuit_breaker_timeout: The number of seconds before the circuit breaker resets
            Set to 0 to effectively disable the circuit breaker
        """
        self.client_id = client_id
        self.client_secret = client_secret
        if dev:
            self.auth_url = DEV_INFRA_AUTH_CLIENT_URL
            self.root_url = DEV_INFRA_API_HYPERION_ROOT
        else:
            self.auth_url = INFRA_AUTH_CLIENT_URL
            self.root_url = INFRA_API_HYPERION_ROOT
        super().__init__(
            dev=dev,
            timeout_seconds=timeout_seconds,
            write_timeout_seconds=write_timeout_seconds,
            retry_count=retry_count,
            retry_backoff_factor=retry_backoff_factor,
            retry_status_codes=retry_status_codes,
            retry_methods=retry_methods,
            cache_ttl=cache_ttl,
            circuit_breaker_fail_max=circuit_breaker_fail_max,
            circuit_breaker_timeout=circuit_breaker_timeout
        )

    def connect(self) -> None:
        """Connects the session to infra-api"""
        self.session.headers.update(
            {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Authorization': 'Basic {}'.format(
                    b64encode(f'{self.client_id}:{self.client_secret}'.encode('utf8')).decode('utf8')
                )
            }
        )
        login = self.session.post(url=self.auth_url, data={'grant_type': 'client_credentials'})
        try:
            login.raise_for_status()
        except HTTPError as ex:
            raise InfraApiLoginError(
                f'The provided client ID and secret failed to log in, resulting in a {ex.response.status_code} status '
                f'code with a response of: {ex.response.text}'
            ) from ex
        self.session.headers.update({'Authorization': 'Bearer {}'.format(login.json()['access_token'])})
        super().connect()

    def get(
            self,
            url_path: str,
            headers: Dict[str, str] = None,
            params: Dict[str, Union[str, List[str]]] = None
    ) -> Dict[str, Any]:
        """
        Performs a GET request
        :param url_path: The path under the root URL to hit
        :param headers: The optional headers for the requests. This is merged (overriding) with the session headers
        :param params: The optional query parameters for the request
        :return: The deserialized JSON result from the request
        """
        return self._make_request(
            method=GET,
            url=f'{self.root_url}/{url_path}',
            headers=headers,
            params=params
        )

    def post(
            self,
            url_path: str,
            headers: Dict[str, str] = None,
            params: Dict[str, Union[str, List[str]]] = None,
            json_body: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """
        Performs a POST request
        :param url_path: The path under the root URL to hit
        :param headers: The optional headers for the requests. This is merged (overriding) with the session headers
        :param params: The optional query parameters for the request
        :param json_body: The optional JSON body for the request
        :return: The deserialized JSON result from the request
        """
        return self._make_request(
            method=POST,
            url=f'{self.root_url}/{url_path}',
            headers=headers,
            params=params,
            json_body=json_body
        )

    def put(
            self,
            url_path: str,
            headers: Dict[str, str] = None,
            params: Dict[str, Union[str, List[str]]] = None,
            json_body: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """
        Performs a PUT request
        :param url_path: The path under the root URL to hit
        :param headers: The optional headers for the requests. This is merged (overriding) with the session headers
        :param params: The optional query parameters for the request
        :param json_body: The optional JSON body for the request
        :return: The deserialized JSON result from the request
        """
        return self._make_request(
            method=PUT,
            url=f'{self.root_url}/{url_path}',
            headers=headers,
            params=params,
            json_body=json_body
        )


class DirectConnection(ConnectionManager):
    """Manages direct connections to the API"""

    __slots__ = (
        'session', 'request_map', 'cache', 'breaker', 'habitat', 'region', 'hyperion_root_url',
        'instance_metadata_token'
    )

    home_dir = path.expanduser('~')  # Exists at this level to make testing less painful

    def __init__(
            self,
            region: str = None,
            hyperion_root_url: str = None,
            dev: bool = False,
            timeout_seconds: Union[int, float] = DEFAULT_REQUEST_TIMEOUT,
            write_timeout_seconds: Union[int, float] = DEFAULT_WRITE_TIMEOUT,
            retry_count: int = DEFAULT_RETRY_COUNT,
            retry_backoff_factor: int = DEFAULT_RETRY_BACKOFF_FACTOR,
            retry_status_codes: List[int] = None,
            retry_methods: List[str] = None,
            cache_ttl: int = DEFAULT_CACHE_TTL,
            circuit_breaker_fail_max: int = DEFAULT_CIRCUIT_BREAKER_FAILS,
            circuit_breaker_timeout: int = DEFAULT_CIRCUIT_BREAKER_TIMEOUT
    ) -> None:
        """
        Optionally set the current AWS region manually
        :param region: The AWS region the consumer of this client is running in
            Defaults to the region the application is currently running in if it can be auto-discovered, otherwise a
            RegionNotFoundError is raised.
        :param hyperion_root_url: Optional root URL for hyperion
            This should only be used in debugging scenarios, as the client will normally be auto-discovered based on
            the current region.
            If provided, do NOT include the version component of the URL as it is automatically injected by the client
        :param dev: Used to determine if the client should talk to hyperion in dev or infra
        :param timeout_seconds: The number of seconds to wait before considering a request timed out
        :param write_timeout_seconds: The number of seconds to wait before considering a write request timed out
        :param retry_count: The maximum number of retries
        :param retry_backoff_factor: The exponential backoff factor on retries
            Calculated according to: {backoff factor} * (2 ** ({number of total retries} - 1))
            For example, setting this to 1 Results in an exponential backoff in seconds of 0.5, 1, 2, 4, 8, 16, 32, ...
        :param retry_status_codes: The HTTP status codes on which to retry
        :param retry_methods: The HTTP methods on which to retry
        :param cache_ttl: The request cache TTL in seconds, set to 0 to effectively disable the cache
        :param circuit_breaker_fail_max: The number of failures within the timeout that will trip the breaker
        :param circuit_breaker_timeout: The number of seconds before the circuit breaker resets
            Set to 0 to effectively disable the circuit breaker
        """
        self.region = region
        self.hyperion_root_url = hyperion_root_url
        self.instance_metadata_token = 'invalid'  # Used if necessary to try to determine region from instance metadata
        super().__init__(
            dev=dev,
            timeout_seconds=timeout_seconds,
            write_timeout_seconds=write_timeout_seconds,
            retry_count=retry_count,
            retry_backoff_factor=retry_backoff_factor,
            retry_status_codes=retry_status_codes,
            retry_methods=retry_methods,
            cache_ttl=cache_ttl,
            circuit_breaker_fail_max=circuit_breaker_fail_max,
            circuit_breaker_timeout=circuit_breaker_timeout
        )

    def connect(self) -> None:
        """Connects the session directly to hyperion"""

        # If no hyperion root URL was provided to this instance, attempt to discover the URL for the region
        if not self.hyperion_root_url:

            # If an AWS region was not provided to this instance, check the lambda function default environment variable
            if not self.region:
                self.region = environ.get('AWS_REGION')

            # Failing that, attempt EC2 instance metadata
            if not self.region:
                try:
                    region_metadata_response = requests.get(
                        url='http://169.254.169.254/latest/meta-data/placement/region',
                        headers={'X-aws-ec2-metadata-token': self.instance_metadata_token},
                        timeout=0.5  # Short timeout so that we fail fast in case we aren't running on EC2
                    )
                    if region_metadata_response.status_code == 401:
                        # The instance metadata session is probably expired, refresh it and try the request again
                        instance_metadata_token_response = requests.put(
                            url='http://169.254.169.254/latest/api/token',
                            headers={'X-aws-ec2-metadata-token-ttl-seconds': INSTANCE_METADATA_TOKEN_TIMEOUT},
                            timeout=0.5
                        )
                        instance_metadata_token_response.raise_for_status()
                        self.instance_metadata_token = instance_metadata_token_response.text
                        region_metadata_response = requests.get(
                            url='http://169.254.169.254/latest/meta-data/placement/region',
                            headers={'X-aws-ec2-metadata-token': self.instance_metadata_token},
                            timeout=0.5
                        )
                    region_metadata_response.raise_for_status()
                    self.region = region_metadata_response.text
                except (ConnectionError, ReadTimeout):
                    pass  # We probably aren't running on an EC2 instance in this case

            # Finally, attempt to look in the local AWS config/credentials info
            if not self.region:
                aws_config_dir = path.join(self.home_dir, '.aws')
                aws_config = ConfigParser()
                aws_config.read(path.join(aws_config_dir, 'config'))
                if 'default' in aws_config.sections():
                    self.region = aws_config['default'].get('region')
                if not self.region:  # The config file is not always present, try the credentials file too
                    aws_credentials = ConfigParser()
                    aws_credentials.read(path.join(aws_config_dir, 'credentials'))
                    if 'default' in aws_credentials.sections():
                        self.region = aws_credentials['default'].get('region')

            # If no region was provided or inferred, raise an exception as it is now impossible to continue
            if not self.region:
                raise RegionNotFoundError(
                    'The AWS region was not provided to this instance and it was not able to be auto-discovered'
                )

            # If we have a region, create the URL
            split_region = self.region.split('-')
            short_region = split_region[0]
            short_region += REGION_SHORT_NAME_MAP[split_region[1]]
            short_region += split_region[2]
            self.hyperion_root_url = f'https://hyperion.prv-{short_region}.{self.habitat}-pure.cloud/v1'

        # Run the parent connect function to ensure the default headers are set on subsequent requests for this session
        super().connect()

    def get(
            self,
            url_path: str,
            headers: Dict[str, str] = None,
            params: Dict[str, Union[str, List[str]]] = None
    ) -> Dict[str, Any]:
        """
        Performs a GET request
        :param url_path: The path under the root URL to hit
        :param headers: The optional headers for the requests. This is merged (overriding) with the session headers
        :param params: The optional query parameters for the request
        :return: The deserialized JSON result from the request
        """
        return self._make_request(
            method=GET,
            url=f'{self.hyperion_root_url}/{url_path}',
            headers=headers,
            params=params
        )
